<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>EliteDangerous - Offline Keybinder (de)</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      color: #fff;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .header {
      background: rgba(0,0,0,.3);
      padding: 20px;
      text-align: center;
      box-shadow: 0 4px 20px rgba(0,0,0,.3);
      width: 100%;
    }
    .header h1 {
      font-size: 2.2rem;
      color: #c65d0c;
      text-shadow: 0 0 10px rgba(255,100,0,.5);
      margin-bottom: 10px;
      transition: text-shadow .25s ease, filter .25s ease, color .2s ease;
      cursor: pointer;
    }
    .header h1:hover, .header h1:focus-visible {
      outline: none;
      text-shadow:
        0 0 3px rgba(255,255,255,.85),
        0 0 12px rgba(255,255,255,.55),
        0 0 22px rgba(255,150,50,.7);
      filter: drop-shadow(0 0 8px rgba(255,255,255,.35));
    }
    .header h2, .header h3, .header h4 { margin-bottom: 12px; font-weight: normal; }
    .header a { color: #ff6600; text-decoration: none; transition: color .3s ease; }
    .header a:hover { color: #fff; }

    .scrolling-text-container {
      --pad-x: 14px;
      --border-w: 6px;
      --offset: calc(var(--pad-x) + var(--border-w));
      width: 100%;
      max-width: none;
      overflow: hidden;
      background-color: #1d1c1c;
      padding: 6px var(--pad-x);
      margin-top: 8px;
      border: var(--border-w) solid #333;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0,0,0,.1);
    }
    .scrolling-text {
      display: inline-block;
      white-space: nowrap;
      color: #e76908;
      font-size: clamp(.9rem, 1.6vw, 1rem);
      line-height: 1.25;
      animation: marquee 55s linear infinite;
    }
    @keyframes marquee {
      0%   { transform: translateX(calc(100% + var(--offset))); }
      100% { transform: translateX(calc(-100% - var(--offset))); }
    } 100% { transform: translateX(-100%);} }

    .devices-box {
      width: 90%;
      max-width: clamp(1300px, 96vw, 1800px);
      margin: 14px auto 0;
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(255,255,255,.2);
      border-radius: 12px;
      box-shadow: 0 6px 16px rgba(0,0,0,.25);
      overflow: hidden;
    }
    .devices-box header {
      display: flex; align-items: center; justify-content: space-between;
      padding: 10px 14px; background: rgba(0,0,0,.4);
    }
    .devices-box header h3 { font-size: 1.1rem; color: #ffd699; font-weight: 700; }
    .devices-box .content { padding: 12px 14px; }
    .device-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 10px;
    }
    .device-card {
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 10px;
      padding: 10px 12px;
      transition: background .2s ease, border-color .2s ease;
    }
    .device-card.connected {
      background: rgba(0, 200, 100, 0.18);
      border-color: rgba(0, 255, 120, 0.55);
    }
    .device-card h4 { font-size: .95rem; color: #ffb86b; margin-bottom: 6px; display:flex; align-items:center; gap:8px; }
    .device-card .meta { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: .85rem; color: #cfe6ff; word-break: break-word; }
    .badge {
      display: inline-block;
      padding: 2px 8px; border-radius: 999px; font-size: .7rem;
      background: rgba(99, 179, 237, .15); border: 1px solid rgba(99, 179, 237, .35); color: #bde0ff;
      text-transform: capitalize;
    }
    .devices-actions { display:flex; gap:8px; }
    .devices-actions button {
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.18);
      color: #fff; padding: 6px 10px; border-radius: 8px; cursor: pointer;
    }
    .devices-actions button:hover { background: rgba(255,255,255,.14); }

    .controls {
      padding: 18px; display: flex; gap: 16px; justify-content: center; flex-wrap: wrap; width: 100%;
    }

    .btn {
      background: linear-gradient(135deg, #fe5a02 0%, #211605 100%);
      border: none; color: white; padding: 12px 22px; font-size: 15px; font-weight: 600;
      border-radius: 10px; cursor: pointer;
      transition: box-shadow .25s ease, transform .2s ease;
      box-shadow: 0 4px 40px rgba(0,0,0,.3);
      text-transform: uppercase; letter-spacing: .5px;
      position: relative;
    }
    .btn-load { background: linear-gradient(135deg,#4CAF50 0%,#2E7D32 100%); box-shadow: 0 4px 40px rgba(76,175,80,.3); }
    .btn-download { background: linear-gradient(135deg,#2196F3 0%,#1565C0 100%); box-shadow: 0 4px 40px rgba(33,150,243,.3); }
    .btn-reset { background: linear-gradient(135deg,#FF5722 0%,#D32F2F 100%); box-shadow: 0 4px 40px rgba(255,87,34,.3); }
    .btn-template { background: linear-gradient(135deg,#9C27B0 0%,#7B1FA2 100%); box-shadow: 0 4px 40px rgba(156,39,176,.3); }
    #toggle-sound-btn { background: linear-gradient(135deg, #4CAF50 0%, #02130a 100%); box-shadow: 0 4px 40px rgba(4,249,13,.3); }

    .file-input { display: none; }
    .file-label {
      display: inline-block; background: linear-gradient(135deg,#4CAF50 0%,#2E7D32 100%); color: white;
      padding: 12px 22px; border-radius: 10px; cursor: pointer;
      transition: box-shadow .25s ease, transform .2s ease;
      box-shadow: 0 4px 40px rgba(76,175,80,.3);
      font-size: 15px; font-weight: 600; text-transform: uppercase; letter-spacing: .5px;
      position: relative;
    }

    .btn:hover, .btn:focus-visible,
    .file-label:hover, .file-label:focus-visible {
      outline: none;
      transform: translateY(0);
      box-shadow:
        0 0 0 2px rgba(255,255,255,.55),
        0 0 22px 8px rgba(255,255,255,.35),
        0 8px 40px rgba(0,0,0,.35);
    }
    #toggle-sound-btn:hover, #toggle-sound-btn:focus-visible {
      outline: none;
      box-shadow:
        0 0 0 2px rgba(255,255,255,.55),
        0 0 22px 8px rgba(255,255,255,.35),
        0 8px 40px rgba(0,0,0,.35);
    }

    .container { padding: 18px; max-width: 1400px; width: 100%; margin: 0 auto; }

    .search-box {
      width: 100%; max-width: 420px; margin: 0 auto 16px; padding: 10px 12px;
      background: rgba(253,89,0,.1); border: 4px solid rgba(0,0,0,.3);
      color: #fff; border-radius: 8px; font-size: 15px; display: block;
    }
    .search-box::placeholder { color: #ccc; }

    .accordion{ display:flex; flex-direction:column; gap:12px; }
    .ac-item{ background: rgba(202,93,4,.1); border-radius: 12px; border: 1px solid rgba(255,255,255,.2); overflow: hidden; }
    .ac-header{
      width:100%; text-align:left;
      background: linear-gradient(135deg, rgba(0,0,0,.35) 0%, rgba(0,0,0,.5) 100%);
      padding: 14px 18px;
      font-weight: 800; cursor:pointer; border:none;
      display:flex; justify-content:space-between; align-items:center;
      font-size: 1.25rem; letter-spacing: .2px;
      color:#c65d0c;
      text-shadow: 0 0 8px rgba(255,120,40,.35);
      border-left: 4px solid #c65d0c;
    }
    .ac-header:hover, .ac-header:focus-visible { outline: none; box-shadow: inset 0 0 0 9999px rgba(255,255,255,.02); }
    .ac-chevron{ transition: transform .2s ease; }
    .ac-item.open .ac-chevron{ transform: rotate(90deg); }
    .ac-panel{ display:none; padding: 12px 14px; }
    .ac-item.open .ac-panel{ display:block; }

    .binding-item { margin-bottom: 12px; padding: 10px; background: rgba(0,0,0,.2); border-radius: 8px; border-left: 3px solid #ff8000; }
    .binding-label { font-weight: bold; margin-bottom: 8px; color: #fff; display: block; }

    .device-inputs { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 10px; }
    .device-group { background: rgba(0,0,0,.3); padding: 10px; border-radius: 6px; border: 1px solid rgba(255,255,255,.1); }
    .device-group label { display: block; font-size: 0.9rem; color: #ccc; margin-bottom: 5px; }

    input[type="text"] {
      width: 100%; padding: 8px; background: rgba(255,255,255,.1); border: 1px solid rgba(255,255,255,.3);
      color: #fff; border-radius: 4px; transition: all .3s ease;
    }
    input[type="text"]:focus { outline: none; border-color: #ff8000; box-shadow: 0 0 10px rgba(0,212,255,.3); }
    .duplicate-highlight { background-color: rgba(255,71,87,.3) !important; border-color: #ff4757 !important; }

    .template-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,.9); display: none; justify-content: center; align-items: center;
      z-index: 1000; overflow-y: auto;
    }
    .template-container {
      background: linear-gradient(135deg,#2c3e50 0%,#34495e 100%);
      padding: 20px; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,.5);
      max-width: 98vw; max-height: 95vh; overflow-y: auto; position: relative;
      width: clamp(1300px, 96vw, 1800px);
    }
    .template-header { text-align: center; margin-bottom: 14px; }
    .template-header h2 { color: #ff8000; margin-bottom: 6px; }
    .template-header p { color: #ffd1d1; }

    /* Tabs */
    .template-tabs { display: flex; flex-wrap: wrap; gap: 8px; margin: 10px auto 14px; justify-content: center; }
    .template-tab {
      padding: 8px 12px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 999px;
      cursor: pointer;
      user-select: none;
      font-weight: 700;
      color: #ffd7b0;
    }
    .template-tab.active { background: rgba(255,128,0,.25); border-color: rgba(255,128,0,.6); color: #fff; }

    /* Body: Ger√§te UNTER der Tastatur (immer einspaltig) */
    .template-body { display: grid; grid-template-columns: 1fr; gap: 14px; align-items: start; }
    .keyboard-template { display: grid; gap: 8px; }
    .devices-template { display: flex; flex-direction: column; gap: 10px; }

    .device-panel { background: rgba(0,0,0,.25); border: 1px solid rgba(255,255,255,.15); border-radius: 8px; padding: 10px; }
    .device-panel h4 { color: #ffd699; margin-bottom: 6px; }
    .device-list { display: grid; grid-template-columns: 1fr; gap: 6px; }
    .device-list-item { background: rgba(0,0,0,.35); border: 1px solid rgba(255,255,255,.08); border-radius: 6px; padding: 6px 8px; }

    /* Keyboard keys ‚Äì gr√∂√üer & besser lesbar */
    .key {
      background: linear-gradient(135deg,#34495e 0%,#2c3e50 100%);
      border: 2px solid #7f8c8d; color: #ecf0f1; border-radius: 8px;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      padding: 6px 6px; min-width: 40px; min-height: 62px;
    }
    .key.assigned{ background: linear-gradient(135deg,#e74c3c 0%,#c0392b 100%); border-color: #e74c3c; }
    .key .top { font-size: calc(var(--key-font-top) * var(--kb-zoom)); }
    .key .fn { font-size: calc(var(--key-font-fn) * var(--kb-zoom)); max-width: calc(220px * var(--kb-zoom)); white-space: normal; line-height: 1.15; word-break: break-word; }

    /* Sizing */
    .w-1 { grid-column: span 1; }
    .w-2 { grid-column: span 2; }
    .w-3 { grid-column: span 3; }
    .w-4 { grid-column: span 4; }
    .w-5 { grid-column: span 5; }
    .w-6 { grid-column: span 6; }
    .w-7 { grid-column: span 7; }
    .w-8 { grid-column: span 8; }
    .w-9 { grid-column: span 9; }
    .w-10 { grid-column: span 10; }
    .w-12 { grid-column: span 12; }

    /* ISO layout grid: 24 units left block, 6 units arrows/Nav, 10 units numpad */
    .kb-grid { display: grid; grid-template-columns: repeat(24, 1fr) 12px repeat(6,1fr) 12px repeat(10,1fr); gap: 6px; min-width: calc(1500px * var(--kb-zoom)); grid-auto-flow: dense; align-items: start; }

    .close-template { position: absolute; top: 10px; right: 20px; background: #e74c3c; color: white; border: none; padding: 10px 15px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: bold; }

    @media (max-width: 1100px) {
      .kb-grid { grid-template-columns: repeat(24, 1fr) 12px repeat(6,1fr) 12px repeat(10,1fr); }
    }
    @media (max-width: 768px) {
      .controls { flex-direction: column; align-items: center; }
      .btn, .file-label { width: 100%; max-width: 300px; }
      .keyboard-template { font-size: 10px; }
      .key { min-width: 34px; min-height: 54px; }
    }
  
    /* Layout Toggle */
    .toggle-row { display:flex; justify-content:center; align-items:center; gap:8px; margin: 4px 0 8px; }
    .toggle-btn {
      appearance: none; border: 1px solid rgba(255,255,255,.25); background: rgba(255,255,255,.08);
      color:#fff; padding: 6px 12px; border-radius: 999px; font-weight:700; cursor:pointer;
      transition: background .2s ease, transform .1s ease, border-color .2s ease;
    }
    .toggle-btn:hover { background: rgba(255,255,255,.14); }
    .toggle-btn.active { background: rgba(255,128,0,.25); border-color: rgba(255,128,0,.6); }

    /* Container width presets */
    .template-container { overflow-x: auto;
      --kb-zoom: 1;
      --key-min-w: 40px;
      --key-min-h: 62px;
      --key-font-top: 14px;
      --key-font-fn: 12px;
    }
    .template-container.wide { width: clamp(1500px, 98vw, 2100px); max-width: 98vw; }
    .template-container.narrow { width: clamp(980px, 92vw, 1200px); max-width: 95vw; }

    /* Keep full keyboard grid in wide mode at all sizes */
    @media (max-width: 1100px) {
      .template-container.wide .kb-grid { grid-template-columns: repeat(24, 1fr) 12px repeat(6,1fr) 12px repeat(10,1fr); }
      /* In schmal Modus darf die Tastatur zusammenklappen */
      .template-container.narrow .kb-grid { grid-template-columns: repeat(24, 1fr) 12px repeat(6,1fr) 12px repeat(10,1fr); }
    }

  
    /* Zoom controls */
    .zoom-row { display:flex; justify-content:center; align-items:center; gap:8px; margin: 2px 0 10px; flex-wrap: wrap; }
    .zoom-label { opacity:.8; font-weight:700; margin-right: 2px; }
    .zoom-btn {
      appearance: none; border: 1px solid rgba(255,255,255,.25); background: rgba(255,255,255,.08);
      color:#fff; padding: 6px 10px; border-radius: 999px; font-weight:700; cursor:pointer;
      transition: background .2s ease, transform .2s ease, border-color .2s ease;
    }
    .zoom-btn:hover { background: rgba(255,255,255,.14); }
    .zoom-btn.active { background: rgba(255,128,0,.25); border-color: rgba(255,128,0,.6); }

    /* Always keep keyboard blocks side by side; allow horizontal scroll if too wide */
    .kb-grid { gap: calc(5px * var(--kb-zoom)); }

  
    /* === Draggable Keys (Layout-Editiermodus) === */
    .template-container.editing .key {
      cursor: move;
      outline: 1px dashed rgba(255,255,255,.35);
    }
    .key { transform: translate(var(--dx, 0px), var(--dy, 0px)); }
    .key:active { cursor: grabbing; }

    .template-toolbar {
      display:flex; gap:8px; justify-content:center; align-items:center;
      margin: 6px 0 10px;
      flex-wrap: wrap;
    }
    .template-toolbar .btn-ghost {
      appearance: none; border: 1px solid rgba(255,255,255,.25); background: rgba(255,255,255,.08);
      color:#fff; padding: 8px 12px; border-radius: 999px; font-weight:700; cursor:pointer;
      transition: background .2s ease, transform .1s ease, border-color .2s ease;
    }
    .template-toolbar .btn-ghost:hover { background: rgba(255,255,255,.14); }
    .template-toolbar .btn-ghost.active { background: rgba(255,128,0,.25); border-color: rgba(255,128,0,.6); }

    /* === Print styles === */
    @media print {
      * { box-shadow: none !important; text-shadow: none !important; }
      body { background: #fff !important; color: #000 !important; }
      .header, .devices-box, .controls, .container, #errorOverlay { display: none !important; }
      .template-overlay { position: static; display: block !important; background: none !important; }
      .template-container { width: 100% !important; max-width: none !important; max-height: none !important; overflow: visible !important; background: #fff !important; }
      .template-header p, .toggle-row, .zoom-row, #templateTabs, .close-template, #btnLayoutEdit, #btnResetPositions { display: none !important; }
      .device-panel { page-break-inside: avoid; }
      .key { background: #fff !important; color: #000 !important; border-color: #333 !important; }
      .key.assigned { background: #fee !important; border-color: #c00 !important; }
      .device-list-item.assigned { background: #eef !important; border-color: #99c !important; color: #000 !important; }
    }

  </style>
</head>
<body>
  <!-- AUDIO -->
  <span id="audio"></span>
  <audio id="background-music" loop preload="auto">
    <source src="https://ia803407.us.archive.org/12/items/tchaikovsky-klavierkonzert-nr.-1-ivo-pogorelich-claudio-abbado/DG%20415%20122-1%E2%80%A2f1.mp3" type="audio/mp3">
    Dein Browser unterst√ºtzt das Audio-Element nicht.
  </audio>

  <!-- HEADER -->
  <div class="header" id="top">
    <h1 id="mainTitle" tabindex="0" title="Klicken, um den Titel zu wechseln"><u>EliteDangerous - OfflineKeybinder</u> <small class="ver" style="font-size:.55em;color:#aaa;">v08b</small></h1>
    <div class="scrolling-text-container" id="marquee">
      <p class="scrolling-text">‚å®Ô∏èüñ±Ô∏èüéÆ Elite Dangerous-OfflineKeybinder ‚Äì Erweitert um ein paar Funktionen. Wir versuchen das Programm aktuell zu halten. Besten Dank an Uncovered und Commander Anya, Team Hut&Kraga. ‚å®Ô∏èüñ±Ô∏èüéÆüõ´</p>
    </div>

    <h2 style="color:#06fe02;">Konfigurieren Sie Ihre Tastenbelegungen f√ºr Maus, Tastatur, Gamecontroller und HOTAS.</h2>
    <h4>Urspr√ºnglicher Pfad: C:\Users\DeinBenutzername\AppData\Local\Frontier Developments\Elite Dangerous\Options\Bindings\ (z.B. Custom.4.binds)</h4>
    <h4>Diese Testversion speichert die neue Datei als "Test.binds" in Ihren Download-Ordner. Benennen Sie diese bei Bedarf um und ersetzen Sie die Originaldatei.</h4>
    <h3 style="color:#fff205;">!!! Wichtiger Hinweis: Erstellen Sie vor dem Ersetzen eine Sicherungskopie Ihrer Originaldatei !!!</h3>
    <br>
    <a href="https://www.chaos-rain.de/elite-dangerous/k-i-n-d-e-r-s-corp/" target="_blank" rel="noopener noreferrer" class="discord-link">
      Klick-&gt;chaos-rain.de: -K.I.N.D.E.R.S.- CORP (Eine deutschsprachige Elite Dangerous Community)
    </a>
    <br>
    <a href="https://discord.gg/x2ShF954AN" target="_blank" rel="noopener noreferrer" class="discord-link">
      Klick-&gt;Discord: Hut &amp; Kraga Kompendium (Alles rund um Hard &amp; Software)
    </a>
  </div>
<!-- GER√ÑTE-BOX -->
  <section class="devices-box" aria-live="polite" aria-label="Erkannte Ger√§te">
    <header>
      <h3>Erkannte Ger√§te &amp; IDs</h3>
      <div class="devices-actions">
        <button type="button" onclick="refreshRuntimeDevices(true)" title="Ger√§te-Erkennung aktualisieren">üîé Ger√§te pr√ºfen</button>
        <button type="button" onclick="copyDeviceIds()" title="IDs in die Zwischenablage kopieren">üìã IDs kopieren</button>
      </div>
    </header>
    <div class="content" id="deviceBox"></div>
  </section>

  <br>

  <!-- CONTROLS -->
  <div class="controls" id="controls">
    <label for="fileInput" class="file-label btn-load">üìÅ <strong>Binding Datei laden</strong></label>
    <input type="file" id="fileInput" class="file-input" accept=".binds,.xml" />
    <button class="btn btn-download" onclick="saveConfig()" type="button">üíæ <strong>Test.binds herunterladen</strong></button>
    <button class="btn btn-reset" onclick="resetConfig()" type="button">üîÑ <strong>Zur√ºcksetzen</strong></button>
    <button class="btn btn-template" onclick="showTemplate()" type="button">‚å®Ô∏è <strong>Schablone anzeigen</strong></button>
    <button class="btn" id="toggle-sound-btn" type="button">üéµ <strong>Musik: Ein/Aus</strong></button>
  </div>

  <!-- BINDINGS -->
  <div class="container" id="bindings">
    <input type="text" class="search-box" id="searchBox" placeholder="Suche nach Funktionen..." oninput="filterBindings()">
    <div id="accordion" class="accordion"></div>
  </div>

  <!-- TEMPLATE -->
  <div class="template-overlay" id="templateOverlay">
    <div class="template-container" id="templateContainer">
      <button class="close-template" onclick="closeTemplate()">‚úï</button>
      <div class="template-header">
        <h2>Schablone: Tastatur &amp; Ger√§te</h2>
        <p>Rote Tasten/Zeilen sind belegt.</p>
      </div>
      

      <div class="template-toolbar">
        <button type="button" id="btnLayoutEdit" class="btn-ghost" title="Tasten verschieben/anheften">üîß Layout bearbeiten</button>
        <button type="button" id="btnResetPositions" class="btn-ghost" title="Alle verschobenen Tasten zur√ºcksetzen">‚ü≤ Positionen zur√ºcksetzen</button>
        <button type="button" id="btnPrintTemplate" class="btn-ghost" title="Schablone drucken">üñ®Ô∏è Drucken</button>
      </div>
<div class="toggle-row" role="group" aria-label="Layout umschalten">
  <button type="button" id="btnNarrow" class="toggle-btn">Schmal</button>
  <button type="button" id="btnWide" class="toggle-btn active">Breit</button>
</div>


<div class="zoom-row" role="group" aria-label="Zoomstufe w√§hlen">
  <span class="zoom-label">Zoom:</span>
  <button type="button" id="zoom90" class="zoom-btn">90%</button>
  <button type="button" id="zoom100" class="zoom-btn active">100%</button>
  <button type="button" id="zoom120" class="zoom-btn">120%</button>
  <button type="button" id="zoom140" class="zoom-btn">140%</button>
  <button type="button" id="zoom160" class="zoom-btn">160%</button>
</div>

      <div id="templateTabs" class="template-tabs"></div>
      <div id="templateBody" class="template-body">
        <div id="keyboardTemplate" class="keyboard-template"></div>
        <div id="devicesTemplate" class="devices-template"></div>
      </div>
    </div>
  </div>

  <!-- ERROR -->
  <div class="error-overlay" id="errorOverlay" style="display:none">
    <div class="error-dialog">
      <h3>Doppelte Tastenbelegung erkannt!</h3>
      <p id="errorMessage"></p>
      <div class="error-buttons">
        <button class="btn" onclick="resolveDuplicate(false)" type="button"><strong>√úberspringen</strong></button>
        <button class="btn" onclick="resolveDuplicate(true)" type="button"><strong>Ersetzen</strong></button>
        <button class="btn" onclick="closeError()" type="button"><strong>Abbrechen</strong></button>
      </div>
    </div>
  </div>

  <script>
    /* ========= GLOBALS ========= */

    /* ========= LAYOUT TOGGLE ========= */

    /* ========= ZOOM ========= */
    let templateZoom = parseFloat(localStorage.getItem('templateZoom') || '0.9');
const ZOOM_PRESETS = {
      'zoom90': 0.9,
      'zoom100': 1.0,
      'zoom120': 1.2,
      'zoom140': 1.4,
      'zoom160': 1.6,
    };

    function applyTemplateZoom(z){
      const cont = document.getElementById('templateContainer');
      if (!cont) return;
      // clamp between 0.8 and 2.0
      const val = Math.max(0.8, Math.min(2.0, z || 1));
      cont.style.setProperty('--kb-zoom', val);
      // toggle active buttons
      Object.entries(ZOOM_PRESETS).forEach(([id, v])=>{
        const btn = document.getElementById(id);
        if (btn) btn.classList.toggle('active', Math.abs(v - val) < 0.01);
      });
      // rebuild to ensure ellipses wrap with new sizes
      try { buildTemplate(true); } catch(e){}
    }

    function setupZoomButtons(){
      Object.entries(ZOOM_PRESETS).forEach(([id, val])=>{
        const btn = document.getElementById(id);
        if (btn) btn.onclick = ()=>{
          templateZoom = val;
          localStorage.setItem('templateZoom', String(templateZoom));
          applyTemplateZoom(templateZoom);
        };
      });
    }

    let templateLayoutMode = (localStorage.getItem('templateLayoutMode') || 'wide');

    function applyTemplateLayout(mode){
      const cont = document.getElementById('templateContainer');
      if (!cont) return;
      cont.classList.remove('wide','narrow');
      cont.classList.add(mode);
      const btnN = document.getElementById('btnNarrow');
      const btnW = document.getElementById('btnWide');
      if (btnN && btnW){
        btnN.classList.toggle('active', mode==='narrow');
        btnW.classList.toggle('active', mode==='wide');
      }
      // Rebuild current tab in case sizes changed
      try { buildTemplate(true); } catch(e){}
    }

    function setupLayoutToggle(){
      const btnN = document.getElementById('btnNarrow');
      const btnW = document.getElementById('btnWide');
      if (btnN) btnN.onclick = () => { templateLayoutMode='narrow'; localStorage.setItem('templateLayoutMode', templateLayoutMode); applyTemplateLayout(templateLayoutMode); };
      if (btnW) btnW.onclick = () => { templateLayoutMode='wide'; localStorage.setItem('templateLayoutMode', templateLayoutMode); applyTemplateLayout(templateLayoutMode); };
    }

    let currentConfig = {};
    let categories = {};
    let duplicateContext = null;
    let keyBindings = new Map();
    let musicPlaying = false;
    let audioContext = null;

    let availableDevices = [];
    let deviceIdMap = {};
    let structureMap = {};

    let captureTarget = null; // {input, deviceType, bindingKey}
    let gamepadPoll = null;
    const AXIS_THRESHOLD = 0.6;

    const HOTAS_HINTS = [
      /HOTAS/i, /Warthog/i, /X52/i, /X-?56/i, /X-?55/i, /T\.?.?16000/i,
      /ThrustMasterTFlightHOTASX/i, /T\.?.?Flight/i, /Virpil/i, /VKB/i, /X\.?.?45/i
    ];

    function classifyDeviceId(id) {
      if (!id || id === '{NoDevice}') return { kind: 'unknown', label: id };
      if (id === 'GamePad' || /GamePad/i.test(id)) return { kind: 'gamepad', label: 'Gamecontroller' };
      if (HOTAS_HINTS.some(rx => rx.test(id))) return { kind: 'hotas', label: 'HOTAS' };
      return { kind: 'joystick', label: 'Joystick' };
    }

    function detectControllerFamily(id=''){
      const s = String(id).toLowerCase();
      if (/(xbox|xinput|microsoft|x-box|360)/i.test(id)) return 'xbox';
      if (/(dualshock|dualsense|playstation|sony|wireless controller)/i.test(id)) return 'playstation';
      return 'generic';
    }

    function getFamilyByKey(deviceKey){
      const dev = availableDevices.find(d=>d.key===deviceKey);
      return (dev && dev.family) ? dev.family : 'generic';
    }

    /* ========= RUNTIME GAMEPAD/DEVICES ========= */
    function refreshRuntimeDevices(){
      // keyboard & mouse always present
      availableDevices.forEach(d => { d.connected = (d.kind === 'keyboard' || d.kind === 'mouse') ? true : d.connected; });

      if ('getGamepads' in navigator) {
        const list = Array.from(navigator.getGamepads ? navigator.getGamepads() : []).filter(Boolean);
        list.forEach((gp, idx) => {
          let entry = availableDevices.find(d => d.kind === 'gamepad' && (d.runtimeId === gp.id || d.id === 'GamePad'));
          if (!entry) {
            const hasBase = !!availableDevices.find(d=>d.key==='gamepad');
            const key = hasBase ? `gamepad${idx+1}` : 'gamepad';
            entry = { key, id: 'GamePad', label: `Gamecontroller (${gp.id || 'GamePad'})`, kind: 'gamepad', connected: true, runtimeId: gp.id || 'GamePad', family: detectControllerFamily(gp.id) };
            availableDevices.push(entry);
            if (!hasBase) deviceIdMap['GamePad'] = 'gamepad';
          } else {
            entry.label = `Gamecontroller (${gp.id || entry.id})`;
            entry.connected = true;
            entry.runtimeId = gp.id || 'GamePad';
            entry.family = detectControllerFamily(gp.id || entry.runtimeId || '');
          }
        });

        // ensure baseline slot
        let base = availableDevices.find(d => d.key === 'gamepad');
        if (!base) {
          base = { key: 'gamepad', id: 'GamePad', label: 'Gamecontroller (noch nicht aktiviert ‚Äì Knopf dr√ºcken)', kind: 'gamepad', connected: false, family: 'generic' };
          availableDevices.push(base);
          deviceIdMap['GamePad'] = 'gamepad';
        } else if (!base.connected && (!list || !list.length)) {
          base.label = 'Gamecontroller (noch nicht aktiviert ‚Äì Knopf dr√ºcken)';
          base.family = 'generic';
        }
      }

      renderDeviceBox();
      if (document.getElementById('templateOverlay').style.display === 'flex') {
        buildTemplate(true);
      }
      try { renderAccordion(); } catch(e) {}
    }

    // gentle autoscan for first few seconds
    function startAutoScan(){
      refreshRuntimeDevices();
      let count = 0;
      const h = setInterval(()=>{
        refreshRuntimeDevices();
        if (++count > 20) clearInterval(h); // ~10s at 500ms
      }, 500);
    }

    /* ========= XML ‚Üí Ger√§te ========= */
    function initAvailableDevices(xmlDoc) {
      availableDevices = [
        { key: 'keyboard', id: 'Keyboard', label: 'Tastatur', kind: 'keyboard', connected: true },
        { key: 'mouse',    id: 'Mouse',    label: 'Maus',      kind: 'mouse',    connected: true }
      ];
      deviceIdMap = { 'Keyboard': 'keyboard', 'Mouse': 'mouse' };

      const ids = new Set();
      xmlDoc.querySelectorAll('Primary, Secondary, Binding, Modifier').forEach(n => {
        const d = n.getAttribute('Device');
        if (d && d !== '{NoDevice}' && d !== 'Keyboard' && d !== 'Mouse') ids.add(d);
      });
      const others = Array.from(ids).sort();

      const byKind = { gamepad: [], hotas: [], joystick: [] };
      others.forEach(id => {
        const k = classifyDeviceId(id).kind;
        (byKind[k] || byKind.joystick).push(id);
      });

      byKind.gamepad.forEach((d, i) => {
        const key = i === 0 ? 'gamepad' : `gamepad${i+1}`;
        availableDevices.push({ key, id: d, label: 'Gamecontroller', kind: 'gamepad', connected: false, family: detectControllerFamily(d) });
        deviceIdMap[d] = key;
      });
      byKind.hotas.forEach((d, i) => {
        const key = i === 0 ? 'joystick1' : `joystick${i+1}`;
        availableDevices.push({ key, id: d, label: `Joystick ${i+1} / HOTAS (${d.replace(/_/g,' ')})`, kind: 'joystick', connected: false });
        deviceIdMap[d] = key;
      });
      byKind.joystick.forEach((d, i) => {
        const idx = i + 1 + byKind.hotas.length;
        const key = `joystick${idx}`;
        availableDevices.push({ key, id: d, label: `Joystick ${idx} (${d.replace(/_/g,' ')})`, kind: 'joystick', connected: false });
        deviceIdMap[d] = key;
      });

      if ('getGamepads' in navigator) {
        if (!availableDevices.find(d => d.key === 'gamepad')) {
          availableDevices.push({ key: 'gamepad', id: 'GamePad', label: 'Gamecontroller (noch nicht aktiviert ‚Äì Knopf dr√ºcken)', kind: 'gamepad', connected: false, family: 'generic' });
          deviceIdMap['GamePad'] = 'gamepad';
        }
      }
    }

    function keyToDeviceId(uiKey) {
      const dev = availableDevices.find(d => d.key === uiKey);
      return dev ? dev.id : '{NoDevice}';
    }

    /* ========= KEY LABELS / TOKENS ========= */
    const keyMapping = {
      'Key_Escape':'Esc',
      'Key_F1':'F1','Key_F2':'F2','Key_F3':'F3','Key_F4':'F4','Key_F5':'F5','Key_F6':'F6',
      'Key_F7':'F7','Key_F8':'F8','Key_F9':'F9','Key_F10':'F10','Key_F11':'F11','Key_F12':'F12',
      'Key_Grave':'^',
      'Key_1':'1','Key_2':'2','Key_3':'3','Key_4':'4','Key_5':'5','Key_6':'6','Key_7':'7','Key_8':'8','Key_9':'9','Key_0':'0',
      'Key_Q':'Q','Key_W':'W','Key_E':'E','Key_R':'R','Key_T':'T','Key_Z':'Z','Key_U':'U','Key_I':'I','Key_O':'O','Key_P':'P',
      'Key_A':'A','Key_S':'S','Key_D':'D','Key_F':'F','Key_G':'G','Key_H':'H','Key_J':'J','Key_K':'K','Key_L':'L',
      'Key_Y':'Y','Key_X':'X','Key_C':'C','Key_V':'V','Key_B':'B','Key_N':'N','Key_M':'M',
      'Key_Comma':',','Key_Period':'.','Key_Slash':'/',
      'Key_Backspace':'Back',
      'Key_Tab':'Tab',
      'Key_CapsLock':'Caps',
      'Key_Enter':'Enter',
      'Key_LeftShift':'Shift','Key_RightShift':'R-Shift',
      'Key_LeftControl':'Strg','Key_RightControl':'R-Strg','Key_LeftAlt':'Alt','Key_RightAlt':'AltGr',
      'Key_Space':'Space',
      'Key_Insert':'Einfg','Key_Delete':'Entf','Key_Home':'Pos1','Key_End':'Ende','Key_PageUp':'Bild ‚Üë','Key_PageDown':'Bild ‚Üì',
      'Key_UpArrow':'‚Üë','Key_DownArrow':'‚Üì','Key_LeftArrow':'‚Üê','Key_RightArrow':'‚Üí',

      'Key_Numpad_7':'Num 7','Key_Numpad_8':'Num 8','Key_Numpad_9':'Num 9','Key_Numpad_Divide':'Num /',
      'Key_Numpad_4':'Num 4','Key_Numpad_5':'Num 5','Key_Numpad_6':'Num 6','Key_Numpad_Multiply':'Num *',
      'Key_Numpad_1':'Num 1','Key_Numpad_2':'Num 2','Key_Numpad_3':'Num 3','Key_Numpad_Subtract':'Num -',
      'Key_Numpad_0':'Num 0','Key_Numpad_Enter':'Num Enter','Key_Numpad_Add':'Num +',
      'Key_Numpad_Decimal':'Num ,',

      'Mouse_1':'Maus L','Mouse_2':'Maus R','Mouse_3':'Maus M','Mouse_4':'Maus 4','Mouse_5':'Maus 5',
      'Mouse_WheelUp':'Rad ‚Üë','Mouse_WheelDown':'Rad ‚Üì','Mouse_WheelLeft':'Rad ‚Üê','Mouse_WheelRight':'Rad ‚Üí'
    };

    function labelGamepadToken(token, family='generic'){
      if (!token) return '';
      const btnMapXbox = {
        0:'A',1:'B',2:'X',3:'Y',
        4:'LB',5:'RB',6:'LT',7:'RT',
        8:'View',9:'Menu',10:'LS',11:'RS',
        12:'D-Pad ‚Üë',13:'D-Pad ‚Üì',14:'D-Pad ‚Üê',15:'D-Pad ‚Üí',16:'Xbox'
      };
      const btnMapPS = {
        0:'√ó',1:'‚óã',2:'‚ñ°',3:'‚ñ≥',
        4:'L1',5:'R1',6:'L2',7:'R2',
        8:'Share',9:'Options',10:'L3',11:'R3',
        12:'Steuerkreuz ‚Üë',13:'Steuerkreuz ‚Üì',14:'Steuerkreuz ‚Üê',15:'Steuerkreuz ‚Üí',16:'PS'
      };
      const axisNames = ['LS X','LS Y','RS X','RS Y']; // 0..3
      if (/^GamePad_Button(\d+)$/.test(token)){
        const n = parseInt(token.match(/^GamePad_Button(\d+)$/)[1],10);
        const map = (family==='playstation') ? btnMapPS : (family==='xbox' ? btnMapXbox : btnMapXbox);
        return map[n] ?? `Button ${n}`;
      }
      if (/^GamePad_Axis(\d+)([+-])$/.test(token)){
        const [,a,pm] = token.match(/^GamePad_Axis(\d+)([+-])$/);
        const idx = parseInt(a,10);
        const base = axisNames[idx] || `Axis ${idx}`;
        if (base.includes('X')) return base + (pm==='+' ? ' ‚Üí' : ' ‚Üê');
        if (base.includes('Y')) return base + (pm==='+' ? ' ‚Üì' : ' ‚Üë');
        return base + (pm==='+' ? '+' : '-');
      }
      return token.replace(/^GamePad_/, 'GamePad ');
    }

    /* ========= SOUND ========= */
    function toggleSound() {
      const audio = document.getElementById('background-music');
      const btn = document.getElementById('toggle-sound-btn');
      if (!musicPlaying) {
        createAudioContext();
        audio.play().then(() => {
          musicPlaying = true; btn.innerHTML = 'üîá <strong>Musik: Ausschalten</strong>'; btn.classList.remove('paused');
        }).catch(() => {});
      } else {
        audio.pause(); musicPlaying = false; btn.innerHTML = 'üéµ <strong>Musik: Einschalten</strong>'; btn.classList.add('paused');
      }
    }
    function createAudioContext() {
      if (!audioContext) {
        try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); }
        catch (e) {}
      }
    }

    /* ========= TEMPLATE (TABS) ========= */
    function showTemplate() {
      buildTemplate();
      document.getElementById('templateOverlay').style.display = 'flex';
      setupLayoutToggle();
      applyTemplateLayout(templateLayoutMode);
      setupZoomButtons();
      applyTemplateZoom(templateZoom);
    }
    function closeTemplate() { document.getElementById('templateOverlay').style.display = 'none'; }

    function buildTemplate(keepTab){
      const tabsHost = document.getElementById('templateTabs');
      const body = document.getElementById('templateBody');
      if (!tabsHost || !body) return;
      tabsHost.innerHTML = '';

      const tabNames = ['Gesamt', ...Object.keys(categories)];
      const current = keepTab && tabsHost.dataset.active ? tabsHost.dataset.active : 'Gesamt';

      tabNames.forEach(name => {
        const b = document.createElement('button');
        b.className = 'template-tab' + (name===current ? ' active' : '');
        b.textContent = name;
        b.addEventListener('click', ()=>{
          tabsHost.dataset.active = name;
          Array.from(tabsHost.children).forEach(ch=>ch.classList.remove('active'));
          b.classList.add('active');
          renderTemplateTab(name);
        });
        tabsHost.appendChild(b);
      });
      tabsHost.dataset.active = current;
      renderTemplateTab(current);
    }

    function renderTemplateTab(name){
      const kbHost = document.getElementById('keyboardTemplate');
      const devHost = document.getElementById('devicesTemplate');
      if (!kbHost || !devHost) return;
      kbHost.innerHTML = '';
      devHost.innerHTML = '';

      // filter for this tab
      let allowed = null;
      if (name !== 'Gesamt') {
        allowed = new Set(categories[name] || []);
      }

      generateKeyboardLayout(kbHost, allowed);
      generateDevicesPanels(devHost, allowed);
    }

    // Build ISO-like QWERTZ keyboard grid with labels and function captions
    function generateKeyboardLayout(host, allowedSet){
      const kb = document.createElement('div');
      kb.className = 'kb-grid';

      // helper to add a key div
      function addKey(token, gridStart, gridSpan){
        const el = document.createElement('div');
        el.className = 'key w-1';
        el.dataset.token = token;
        el.style.gridColumn = gridStart + ' / span ' + (gridSpan||1);
        const top = document.createElement('div');
        top.className = 'top';
        top.textContent = keyMapping[token] || token.replace(/^Key_/,'').replace(/^Mouse_/,'M ');
        const fn = document.createElement('div');
        fn.className = 'fn';

        // find assigned function for this token (keyboard only)
        let funcName = '';
        for (const [binding, devices] of Object.entries(currentConfig)) {
          if (allowedSet && !allowedSet.has(binding)) continue;
          if (devices && devices.keyboard === token) { funcName = formatBindingName(binding); break; }
        }
        if (funcName) { el.classList.add('assigned'); fn.textContent = funcName; }

        el.appendChild(top);
        el.appendChild(fn);
        // apply saved offset
        try { applyOffsetToKeyEl(el, token); } catch(e){}
        kb.appendChild(el);
      }

      // Left block (24 units)
      let col = 1;
      // Row 1: Esc + F1..F12
      addKey('Key_Escape', col, 2); col += 3;
      const fkeys = ['Key_F1','Key_F2','Key_F3','Key_F4','Key_F5','Key_F6','Key_F7','Key_F8','Key_F9','Key_F10','Key_F11','Key_F12'];
      fkeys.forEach(k=>{ addKey(k, col, 2); col += 2; });

      // Row 2: ^ 1..0 Backspace
      col = 1;
      const row2 = ['Key_Grave','Key_1','Key_2','Key_3','Key_4','Key_5','Key_6','Key_7','Key_8','Key_9','Key_0'];
      row2.forEach(k=>{ addKey(k, col, 2); col += 2; });
      addKey('Key_Backspace', col, 4);

      // Row 3: Tab + Q W E R T Z U I O P
      col = 1;
      addKey('Key_Tab', col, 3); col += 3;
      const row3 = ['Key_Q','Key_W','Key_E','Key_R','Key_T','Key_Z','Key_U','Key_I','Key_O','Key_P'];
      row3.forEach(k=>{ addKey(k, col, 2); col += 2; });

      // Row 4: Caps + A S D F G H J K L + Enter
      col = 1;
      addKey('Key_CapsLock', col, 4); col += 4;
      const row4 = ['Key_A','Key_S','Key_D','Key_F','Key_G','Key_H','Key_J','Key_K','Key_L'];
      row4.forEach(k=>{ addKey(k, col, 2); col += 2; });
      addKey('Key_Enter', col, 4);

      // Row 5: Shift + Y X C V B N M , . / + R-Shift
      col = 1;
      addKey('Key_LeftShift', col, 5); col += 5;
      const row5 = ['Key_Y','Key_X','Key_C','Key_V','Key_B','Key_N','Key_M','Key_Comma','Key_Period','Key_Slash'];
      row5.forEach(k=>{ addKey(k, col, 2); col += 2; });
      addKey('Key_RightShift', col, 5);

      // Row 6: Ctrl + Alt + Space + AltGr + R-Ctrl
      col = 1;
      addKey('Key_LeftControl', col, 3); col += 3;
      addKey('Key_LeftAlt', col, 3); col += 3;
      addKey('Key_Space', col, 10); col += 10;
      addKey('Key_RightAlt', col, 3); col += 3;
      addKey('Key_RightControl', col, 3);

      // Middle Nav cluster (6 units)
      function addNavKey(token, c, span){ const off = 24 + 1 + c; addKey(token, off, span||2); }

      // Obere Reihe: Einfg, Entf, Pos1
      addNavKey('Key_Insert', 1);
      addNavKey('Key_Delete', 3);
      addNavKey('Key_Home', 5);
      // Untere Reihe: Ende, Bild ‚Üë, Bild ‚Üì
      addNavKey('Key_End', 1);
      addNavKey('Key_PageUp', 3);
      addNavKey('Key_PageDown', 5);
      // Pfeile: Hoch √ºber Unten, Links/Rechts neben Unten
      addNavKey('Key_UpArrow', 3);
      addNavKey('Key_LeftArrow', 1);
      addNavKey('Key_DownArrow', 3);
      addNavKey('Key_RightArrow', 5);

// Numpad (10 units)
      function addNum(token, c, span){ const off = 24 + 1 + 6 + 1 + c; addKey(token, off, span||2); }
      addNum('Key_Numpad_7',1); addNum('Key_Numpad_8',3); addNum('Key_Numpad_9',5); addNum('Key_Numpad_Divide',7);
      addNum('Key_Numpad_4',1); addNum('Key_Numpad_5',3); addNum('Key_Numpad_6',5); addNum('Key_Numpad_Multiply',7);
      addNum('Key_Numpad_1',1); addNum('Key_Numpad_2',3); addNum('Key_Numpad_3',5); addNum('Key_Numpad_Subtract',7);
      addNum('Key_Numpad_0',1,4); addNum('Key_Numpad_Decimal',5); addNum('Key_Numpad_Add',7);
      addNum('Key_Numpad_Enter',7,2);

      host.appendChild(kb);
    }

    

function generateDevicesPanels(host, allowedSet){
  function makePanel(title){
    const panel = document.createElement('div');
    panel.className = 'device-panel';
    const h = document.createElement('h4'); h.textContent = title; panel.appendChild(h);
    const list = document.createElement('div'); list.className = 'device-list';
    panel.appendChild(list);
    host.appendChild(panel);
    return list;
  }

  // ‚å®Ô∏è Tastatur ‚Äì Textliste aller belegten Keys (pro Tab gefiltert)
  (function(){
    const list = makePanel('‚å®Ô∏è Tastatur');
    let count = 0;
    for (const [binding, devices] of Object.entries(currentConfig)) {
      if (allowedSet && !allowedSet.has(binding)) continue;
      const token = devices ? devices['keyboard'] : '';
      if (token) {
        const item = document.createElement('div');
        item.className = 'device-list-item assigned';
        item.textContent = `${formatKey(token, 'keyboard')} ‚Üí ${formatBindingName(binding)}`;
        list.appendChild(item);
        count++;
      }
    }
    if (!count) {
      const item = document.createElement('div');
      item.className = 'device-list-item';
      item.textContent = 'Keine Belegung';
      list.appendChild(item);
    }
  })();

  // üñ±Ô∏è Maus
  (function(){
    const list = makePanel('üñ±Ô∏è Maus');
    let count = 0;
    for (const [binding, devices] of Object.entries(currentConfig)) {
      if (allowedSet && !allowedSet.has(binding)) continue;
      const token = devices ? devices['mouse'] : '';
      if (token) {
        const item = document.createElement('div');
        item.className = 'device-list-item assigned';
        item.textContent = `${formatKey(token, 'mouse')} ‚Üí ${formatBindingName(binding)}`;
        list.appendChild(item);
        count++;
      }
    }
    if (!count) {
      const item = document.createElement('div');
      item.className = 'device-list-item';
      item.textContent = 'Keine Belegung';
      list.appendChild(item);
    }
  })();

  // üéÆ Gamepads ‚Äì pro erkanntem Pad
  (function(){
    const gps = availableDevices.filter(d => d.kind==='gamepad');
    gps.forEach(dev => {
      const fam = dev.family || 'generic';
      const title = `üéÆ Gamepad${fam ? ' ('+fam+')' : ''}`;
      const list = makePanel(title);
      let count = 0;
      for (const [binding, devices] of Object.entries(currentConfig)) {
        if (allowedSet && !allowedSet.has(binding)) continue;
        const token = devices ? devices[dev.key] : '';
        if (token) {
          const item = document.createElement('div');
          item.className = 'device-list-item assigned';
          const type = 'gamepad';
          item.textContent = `${formatKey(token, type, dev.key)} ‚Üí ${formatBindingName(binding)}`;
          list.appendChild(item);
          count++;
        }
      }
      if (!count) {
        const item = document.createElement('div');
        item.className = 'device-list-item';
        item.textContent = 'Keine Belegung';
        list.appendChild(item);
      }
    });
  })();

  // üïπÔ∏è Joystick/HOTAS ‚Äì wenn keiner verbunden, als 'Gamepad' betiteln (pro Wunsch)
  (function(){
    const joys = availableDevices.filter(d => d.kind==='joystick');
    const anyJoyConnected = joys.some(d=>d.connected);
    joys.forEach(dev => {
      const baseTitle = anyJoyConnected ? `üïπÔ∏è Joystick / HOTAS (${dev.label || dev.key})` : `üéÆ Gamepad (${dev.label || dev.key})`;
      const list = makePanel(baseTitle);
      let count = 0;
      for (const [binding, devices] of Object.entries(currentConfig)) {
        if (allowedSet && !allowedSet.has(binding)) continue;
        const token = devices ? devices[dev.key] : '';
        if (token) {
          const item = document.createElement('div');
          item.className = 'device-list-item assigned';
          // Darstellung als Joystick (Tokens bleiben 1:1 f√ºrs Speichern)
          item.textContent = `${formatKey(token, anyJoyConnected ? 'joystick' : 'gamepad')} ‚Üí ${formatBindingName(binding)}`;
          list.appendChild(item);
          count++;
        }
      }
      if (!count) {
        const item = document.createElement('div');
        item.className = 'device-list-item';
        item.textContent = 'Keine Belegung';
        list.appendChild(item);
      }
    });
  })();
}
/* ========= GER√ÑTE-BOX ========= */


    function renderDeviceBox() {
      const host = document.getElementById('deviceBox');
      if (!host) return;
      host.innerHTML = '';

      const grid = document.createElement('div');
      grid.className = 'device-grid';

      const visible = availableDevices.filter(d => d.connected);
      if (!visible.length) {
        const empty = document.createElement('div');
        empty.innerHTML = 'Keine verbundenen Ger√§te erkannt. <em>Tipp:</em> Bei Gamepads muss oft zuerst eine Taste gedr√ºckt werden. Dann erneut auf ‚ÄûGer√§te pr√ºfen‚Äú klicken.';
        host.appendChild(empty);
        return;
      }

      visible.forEach(d => {
        const card = document.createElement('div');
        card.className = 'device-card connected';
        const title = document.createElement('h4');
        const badge = document.createElement('span');
        badge.className = 'badge';
        badge.textContent = d.family ? d.family : d.kind;
        const titleText = document.createElement('span');
        titleText.textContent = d.label;
        title.appendChild(titleText);
        title.appendChild(badge);

        const meta = document.createElement('div');
        meta.className = 'meta';
        meta.innerHTML = `<div><strong>ID:</strong> ${d.runtimeId || d.id}</div><div><strong>UI-Key:</strong> ${d.key}</div>`;
        card.appendChild(title);
        card.appendChild(meta);
        grid.appendChild(card);
      });

      host.appendChild(grid);
    }

    async function copyDeviceIds() {
      try {
        const lines = availableDevices.filter(d=>d.connected).map(d => `${d.kind}	${d.label}	${d.runtimeId || d.id}	(ui:${d.key})`);
        const txt = lines.join('\n');
        await navigator.clipboard.writeText(txt);
        alert('Ger√§te-IDs kopiert!');
      } catch {
        alert('Kopieren nicht m√∂glich (fehlende Berechtigung).');
      }
    }

    /* ========= CATEGORIES ========= */
    function initializeCategories() {
      categories = {
        'Flug': ['YawLeftButton','YawRightButton','RollLeftButton','RollRightButton','ForwardKey','BackwardKey','UpThrustButton','DownThrustButton','ToggleFlightAssist','UseBoostJuice','SetSpeedZero'],
        'Kampf': ['PrimaryFire','SecondaryFire','DeployHardpointToggle','DeployHeatSink','FireChaffLauncher','CycleFireGroupNext','CycleFireGroupPrevious','ToggleButtonUpInput'],
        'Navigation': ['SelectTarget','CycleNextTarget','SelectHighestThreat','Supercruise','Hyperspace','HyperSuperCombination','SelectTargetsTarget','WingNavLock','CycleNextSubsystem'],
        'Targeting': ['TargetWingman0','TargetWingman1','TargetWingman2','CycleNextHostileTarget','CyclePreviousHostileTarget'],
        'Energie': ['IncreaseEnginesPower','IncreaseWeaponsPower','IncreaseSystemsPower','ResetPowerDistribution'],
        'Radar & Scanner': ['RadarIncreaseRange','RadarDecreaseRange','ExplorationFSSEnter','ExplorationFSSTarget','ExplorationFSSDiscoveryScan'],
        'UI & Panels': ['UIFocus','FocusLeftPanel','FocusCommsPanel','FocusRadarPanel','FocusRightPanel','CycleNextPanel','CyclePreviousPanel','QuickCommsPanel'],
        'Kamera': ['HeadLookToggle','PhotoCameraToggle','VanityCameraOne','VanityCameraTwo','ToggleFreeCam','FreeCamToggleHUD','PlayerHUDModeToggle'],
        'Schiff Systeme': ['LandingGearToggle','ToggleCargoScoop','ShipSpotLightToggle','NightVisionToggle','OrbitLinesToggle'],
        'SRV': ['SteeringAxis','BuggyPrimaryFireButton','BuggySecondaryFireButton','VerticalThrustersButton','ToggleBuggyTurretButton','AutoBreakBuggyButton','HeadlightsBuggyButton','RecallDismissShip'],
        'On Foot': ['HumanoidForwardAxis','HumanoidStrafeAxis','HumanoidJumpButton','HumanoidPrimaryFireButton','HumanoidZoomButton','HumanoidSprintButton','HumanoidCrouchButton','HumanoidReloadButton','HumanoidSwitchWeapon'],
        'Kommunikation': ['MicrophoneMute','OpenCodexGoToDiscovery'],
        'Sonstige': []
      };
    }

    /* ========= XML PARSER HELPERS ========= */
    function directChildrenByTag(el, tagName) {
      const out = [];
      const t = String(tagName).toLowerCase();
      for (const ch of el.children) if (ch.tagName.toLowerCase() === t) out.push(ch);
      return out;
    }
    function directChild(el, tagName) {
      const list = directChildrenByTag(el, tagName);
      return list.length ? list[0] : null;
    }
    function elementHasAnyBindingChild(el) {
      for (const ch of el.children) {
        const tn = ch.tagName;
        if (tn === 'Primary' || tn === 'Secondary' || tn === 'Binding' || tn === 'Modifier') return true;
      }
      return false;
    }

    /* ========= LOAD CONFIG ========= */
    function loadConfig() {
      const fileInput = document.getElementById('fileInput');
      const file = fileInput.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const parser = new DOMParser();
          const xmlDoc = parser.parseFromString(e.target.result, 'text/xml');
          const parseErr = xmlDoc.querySelector('parsererror');
          if (parseErr) throw new Error('Ung√ºltiges XML / .binds');

          initAvailableDevices(xmlDoc);
          try { refreshRuntimeDevices(); } catch(_) {}

          parseXMLConfig(xmlDoc);
          renderAccordion();
          renderDeviceBox();
          collapseAll(); toggleItem(document.querySelector('.ac-item'));
          if (document.getElementById('templateOverlay').style.display === 'flex') buildTemplate(true);

        } catch (error) {
          console.error(error);
          alert('Fehler beim Laden der XML-Datei: ' + error.message);
        }
      };
      reader.readAsText(file);
    }

    function parseXMLConfig(xmlDoc) {
      currentConfig = {};
      keyBindings.clear();
      structureMap = {};

      const emptyBinding = () => {
        const obj = {};
        availableDevices.forEach(d => obj[d.key] = '');
        return obj;
      };

      const root = xmlDoc.documentElement;
      const children = Array.from(root.children);

      children.forEach(element => {
        const bindingName = element.tagName;
        if (!elementHasAnyBindingChild(element)) return;

        currentConfig[bindingName] = emptyBinding();
        structureMap[bindingName] = {
          primary:   { exists: false, deviceId: '{NoDevice}', key: '', modifier: null },
          secondary: { exists: false, deviceId: '{NoDevice}', key: '', modifier: null },
          bindings:  [],
          params:    []
        };

        const primaryElement = directChild(element, 'Primary');
        if (primaryElement) {
          const dev = primaryElement.getAttribute('Device') || '{NoDevice}';
          const key = primaryElement.getAttribute('Key') || '';
          let modifier = null;
          const modEl = directChild(primaryElement, 'Modifier');
          if (modEl) modifier = { deviceId: modEl.getAttribute('Device') || '{NoDevice}', key: modEl.getAttribute('Key') || '' };

          structureMap[bindingName].primary = { exists: true, deviceId: dev, key, modifier };
          const uiKey = deviceIdMap[dev] || (dev === 'Keyboard' ? 'keyboard' : dev === 'Mouse' ? 'mouse' : null);
          if (uiKey && key && dev !== '{NoDevice}') {
            currentConfig[bindingName][uiKey] = key;
            keyBindings.set(`${uiKey}-${key}`, bindingName);
          }
        }

        const secondaryElement = directChild(element, 'Secondary');
        if (secondaryElement) {
          const dev = secondaryElement.getAttribute('Device') || '{NoDevice}';
          const key = secondaryElement.getAttribute('Key') || '';
          let modifier = null;
          const modEl = directChild(secondaryElement, 'Modifier');
          if (modEl) modifier = { deviceId: modEl.getAttribute('Device') || '{NoDevice}', key: modEl.getAttribute('Key') || '' };

          structureMap[bindingName].secondary = { exists: true, deviceId: dev, key, modifier };
          const uiKey = deviceIdMap[dev] || (dev === 'Keyboard' ? 'keyboard' : dev === 'Mouse' ? 'mouse' : null);
          if (uiKey && key && dev !== '{NoDevice}') {
            currentConfig[bindingName][uiKey] = key;
            keyBindings.set(`${uiKey}-${key}`, bindingName);
          }
        }

        directChildrenByTag(element, 'Binding').forEach(ax => {
          const dev = ax.getAttribute('Device') || '{NoDevice}';
          const key = ax.getAttribute('Key') || '';
          structureMap[bindingName].bindings.push({ deviceId: dev, key });

          const uiKey = deviceIdMap[dev] || (dev === 'Keyboard' ? 'keyboard' : dev === 'Mouse' ? 'mouse' : null);
          if (uiKey && key && dev !== '{NoDevice}') {
            if (!currentConfig[bindingName][uiKey]) {
              currentConfig[bindingName][uiKey] = key;
              keyBindings.set(`${uiKey}-${key}`, bindingName);
            }
          }
        });

        ['Inverted','Deadzone','ToggleOn'].forEach(pn => {
          directChildrenByTag(element, pn).forEach(p => {
            structureMap[bindingName].params.push({ name: pn, value: p.getAttribute('Value') ?? '' });
          });
        });
      });
    }

    /* ========= UI RENDER ========= */
    function renderAccordion() {
      const container = document.getElementById('accordion');
      container.innerHTML = '';

      for (const [categoryName, bindingKeys] of Object.entries(categories)) {
        const item = document.createElement('div');
        item.className = 'ac-item';

        const header = document.createElement('button');
        header.className = 'ac-header';
        header.type = 'button';
        header.innerHTML = `<span>${categoryName}</span><span class="ac-chevron">‚ñ∂</span>`;
        header.addEventListener('click', () => toggleItem(item));

        const panel = document.createElement('div');
        panel.className = 'ac-panel';

        for (const bindingKey of bindingKeys) {
          if (currentConfig[bindingKey]) {
            panel.appendChild(createBindingElement(bindingKey, currentConfig[bindingKey]));
          }
        }

        if (categoryName === 'Sonstige') {
          for (const [bindingKey, binding] of Object.entries(currentConfig)) {
            let found = false;
            for (const [catName, catBindings] of Object.entries(categories)) {
              if (catName !== 'Sonstige' && catBindings.includes(bindingKey)) { found = true; break; }
            }
            if (!found) panel.appendChild(createBindingElement(bindingKey, binding));
          }
        }

        if (panel.children.length) {
          item.appendChild(header);
          item.appendChild(panel);
          container.appendChild(item);
        }
      }
    }
    function toggleItem(item) { if (item) item.classList.toggle('open'); }
    function collapseAll() { document.querySelectorAll('.ac-item').forEach(i => i.classList.remove('open')); }

    function editorDevices() {
      return availableDevices.filter(dev => {
        if (dev.key === 'keyboard' || dev.key === 'mouse') return true;
        if (dev.kind === 'gamepad') return true; // baseline sichtbar
        return dev.connected;
      });
    }

    function createBindingElement(bindingKey, binding) {
      const bindingDiv = document.createElement('div');
      bindingDiv.className = 'binding-item';
      bindingDiv.setAttribute('data-binding', bindingKey);

      const label = document.createElement('div');
      label.className = 'binding-label';
      label.textContent = formatBindingName(bindingKey);

      const deviceInputs = document.createElement('div');
      deviceInputs.className = 'device-inputs';

      editorDevices().forEach(dev => {
        const deviceGroup = document.createElement('div');
        deviceGroup.className = 'device-group';

        const deviceLabel = document.createElement('label');
        deviceLabel.textContent = dev.label + (dev.kind==='gamepad' && dev.family ? ` (${dev.family})` : '');

        const input = document.createElement('input');
        input.type = 'text';
        input.value = formatKey(binding[dev.key] || '', dev.kind, dev.key);
        input.setAttribute('data-device', dev.key);
        input.setAttribute('data-binding', bindingKey);
        input.addEventListener('blur', validateBinding);
        input.addEventListener('input', handleInputChange);
        input.addEventListener('focus', () => beginCapture(input));
        input.addEventListener('blur', () => endCapture(input));

        deviceGroup.appendChild(deviceLabel);
        deviceGroup.appendChild(input);
        deviceInputs.appendChild(deviceGroup);
      });

      bindingDiv.appendChild(label);
      bindingDiv.appendChild(deviceInputs);
      return bindingDiv;
    }

    /* ========= INPUT CAPTURE ========= */
    function beginCapture(input) {
      const bindingKey = input.getAttribute('data-binding');
      const deviceType = input.getAttribute('data-device');
      captureTarget = { input, deviceType, bindingKey };
      // Gamepad Poll starten falls n√∂tig
      if (deviceType.startsWith('gamepad')) {
        if (gamepadPoll) clearInterval(gamepadPoll);
        gamepadPoll = setInterval(pollGamepadsForCapture, 30);
      }
    }
    function endCapture(input) {
      if (captureTarget && captureTarget.input === input) captureTarget = null;
      if (gamepadPoll) { clearInterval(gamepadPoll); gamepadPoll = null; }
    }

    function commitCapture(deviceType, bindingKey, token) {
      const input = document.querySelector(`input[data-binding="${CSS.escape(bindingKey)}"][data-device="${CSS.escape(deviceType)}"]`);
      if (!input) return;
      input.value = formatKey(token, deviceType.startsWith('gamepad') ? 'gamepad' : deviceType, deviceType);
      handleInputChange({ target: input });
      validateBinding({ target: input });
      input.blur();
    }

    // Tastatur
    document.addEventListener('keydown', (e) => {
      if (!captureTarget || captureTarget.deviceType !== 'keyboard') return;
      e.preventDefault();
      const token = codeToKeyboardToken(e.code);
      if (token) commitCapture('keyboard', captureTarget.bindingKey, token);
    }, true);

    function codeToKeyboardToken(code){
      const map = {
        'Escape':'Key_Escape',
        'Backquote':'Key_Grave',
        'Backspace':'Key_Backspace',
        'Tab':'Key_Tab',
        'CapsLock':'Key_CapsLock',
        'Enter':'Key_Enter',
        'ShiftLeft':'Key_LeftShift','ShiftRight':'Key_RightShift',
        'ControlLeft':'Key_LeftControl','ControlRight':'Key_RightControl',
        'AltLeft':'Key_LeftAlt','AltRight':'Key_RightAlt',
        'Space':'Key_Space',
        'Insert':'Key_Insert','Delete':'Key_Delete','Home':'Key_Home','End':'Key_End',
        'PageUp':'Key_PageUp','PageDown':'Key_PageDown',
        'ArrowUp':'Key_UpArrow','ArrowDown':'Key_DownArrow','ArrowLeft':'Key_LeftArrow','ArrowRight':'Key_RightArrow',
        'NumpadDivide':'Key_Numpad_Divide','NumpadMultiply':'Key_Numpad_Multiply','NumpadSubtract':'Key_Numpad_Subtract','NumpadAdd':'Key_Numpad_Add','NumpadDecimal':'Key_Numpad_Decimal','NumpadEnter':'Key_Numpad_Enter',
        'Comma':'Key_Comma','Period':'Key_Period','Slash':'Key_Slash'
      };
      if (/^F([1-9]|1[0-2])$/.test(code)) return `Key_${code}`;
      if (/^Digit[0-9]$/.test(code)) return `Key_${code.slice(5)}`;
      if (/^Key[A-Z]$/.test(code)) return `Key_${code.slice(3)}`;
      if (/^Numpad[0-9]$/.test(code)) return `Key_Numpad_${code.slice(6)}`;
      return map[code] || null;
    }

    // Maus
    document.addEventListener('mousedown', (e) => {
      if (!captureTarget || captureTarget.deviceType !== 'mouse') return;
      e.preventDefault();
      let token = null;
      if (e.button === 0) token = 'Mouse_1';
      else if (e.button === 2) token = 'Mouse_2';
      else if (e.button === 1) token = 'Mouse_3';
      else if (e.button === 3) token = 'Mouse_4';
      else if (e.button === 4) token = 'Mouse_5';
      if (token) commitCapture('mouse', captureTarget.bindingKey, token);
    }, true);
    document.addEventListener('wheel', (e) => {
      if (!captureTarget || captureTarget.deviceType !== 'mouse') return;
      e.preventDefault();
      const token = Math.abs(e.deltaY) > Math.abs(e.deltaX)
        ? (e.deltaY < 0 ? 'Mouse_WheelUp' : 'Mouse_WheelDown')
        : (e.deltaX < 0 ? 'Mouse_WheelLeft' : 'Mouse_WheelRight');
      commitCapture('mouse', captureTarget.bindingKey, token);
    }, { passive: false });

    // Gamepad
    function pollGamepadsForCapture(){
      if (!captureTarget || !captureTarget.deviceType.startsWith('gamepad')) return;
      const pads = navigator.getGamepads ? Array.from(navigator.getGamepads()).filter(Boolean) : [];
      for (const gp of pads) {
        // Buttons
        for (let i=0; i<gp.buttons.length; i++){
          const b = gp.buttons[i];
          if (b && b.pressed) {
            commitCapture(captureTarget.deviceType, captureTarget.bindingKey, `GamePad_Button${i}`);
            return;
          }
        }
        // Axes (+/-)
        for (let a=0; a<gp.axes.length; a++){
          const v = gp.axes[a] || 0;
          if (v >= AXIS_THRESHOLD) { commitCapture(captureTarget.deviceType, captureTarget.bindingKey, `GamePad_Axis${a}+`); return; }
          if (v <= -AXIS_THRESHOLD){ commitCapture(captureTarget.deviceType, captureTarget.bindingKey, `GamePad_Axis${a}-`); return; }
        }
      }
    }

    /* ========= HELPERS ========= */
    function formatBindingName(bindingKey) { return bindingKey.replace(/([A-Z])/g, ' $1').trim(); }
    function isFunctionKey(s){ return /^F([1-9]|1[0-2])$/i.test(s); }

    function formatKey(key, kind, deviceKey) {
      if (!key || key === '{NoDevice}') return '';
      if (kind === 'gamepad'){
        const fam = getFamilyByKey(deviceKey || 'gamepad');
        return labelGamepadToken(key, fam);
      }
      if (/^GamePad_/.test(key)) return 'GamePad ' + key.slice(8);
      if (/^Joy_/.test(key)) return 'Joy ' + key.slice(4);
      if (/^Pos_Joy_/.test(key)) return 'Pos Joy ' + key.slice(8);
      if (/^Neg_Joy_/.test(key)) return 'Neg Joy ' + key.slice(8);
      return keyMapping[key] || key.replace(/^Key_/, '').replace(/^Mouse_/, 'Maus ');
    }

    function reverseFormatKey(displayKey, deviceType) {
      if (!displayKey) return '';

      // Try known keyboard labels first
      for (const [originalKey, mappedKey] of Object.entries(keyMapping)) {
        if ((mappedKey || '').toLowerCase() === displayKey.toLowerCase()) return originalKey;
      }

      // Gamepad labels -> tokens
      if (deviceType && deviceType.startsWith('gamepad')) {
        const fam = getFamilyByKey(deviceType);
        const s = displayKey.trim().toLowerCase();
        // Xbox labels
        const xb = {'a':0,'b':1,'x':2,'y':3,'lb':4,'rb':5,'lt':6,'rt':7,'view':8,'menu':9,'ls':10,'rs':11,
                    'd-pad ‚Üë':12,'d-pad up':12,'‚Üë':12,'d-pad ‚Üì':13,'d-pad down':13,'‚Üì':13,'d-pad ‚Üê':14,'d-pad left':14,'‚Üê':14,'d-pad ‚Üí':15,'d-pad right':15,'‚Üí':15,'xbox':16};
        // PlayStation labels
        const ps = {'√ó':0,'x':0,'cross':0,'kreuz':0,'‚óã':1,'o':1,'kreis':1,'circle':1,'‚ñ°':2,'square':2,'quadrat':2,'‚ñ≥':3,'triangle':3,'dreieck':3,
                    'l1':4,'r1':5,'l2':6,'r2':7,'share':8,'options':9,'l3':10,'r3':11,
                    'steuerkreuz ‚Üë':12,'dpad up':12,'‚Üë':12,'steuerkreuz ‚Üì':13,'dpad down':13,'‚Üì':13,'steuerkreuz ‚Üê':14,'dpad left':14,'‚Üê':14,'steuerkreuz ‚Üí':15,'dpad right':15,'‚Üí':15,'ps':16};
        const map = (fam==='playstation') ? ps : xb;
        for (const [k,v] of Object.entries(map)){
          if (s === k) return `GamePad_Button${v}`;
        }
        // Generic fallbacks
        if (/^button\s*\d+$/i.test(s)) return `GamePad_Button${s.replace(/[^0-9]/g,'')}`;
        if (/^axis\s*(\d+)\s*([+\-])$/i.test(s)) {
          const m = s.match(/^axis\s*(\d+)\s*([+\-])$/i);
          return `GamePad_Axis${m[1]}${m[2]}`;
        }
        if (/^gamepad\s+/i.test(displayKey)) return 'GamePad_' + displayKey.replace(/^gamepad\s+/i,'').replace(/\s+/g,'');
        if (!/_/.test(displayKey) && !/^Joy|^Mouse|^Key/i.test(displayKey)) return 'GamePad_' + displayKey.replace(/\s+/g,'');
      }

      if (deviceType && (deviceType.startsWith('joystick') || deviceType.startsWith('hotas'))) {
        if (/^joy\s+/i.test(displayKey)) return 'Joy_' + displayKey.replace(/^joy\s+/i,'').replace(/\s+/g,'');
        if (/^pos\s+joy\s+/i.test(displayKey)) return 'Pos_Joy_' + displayKey.replace(/^pos\s+joy\s+/i,'').replace(/\s+/g,'');
        if (/^neg\s+joy\s+/i.test(displayKey)) return 'Neg_Joy_' + displayKey.replace(/^neg\s+joy\s+/i,'').replace(/\s+/g,'');
        if (!/_/.test(displayKey) && !/^GamePad|^Mouse|^Key/i.test(displayKey)) return 'Joy_' + displayKey.replace(/\s+/g,'');
      }

      if (deviceType === 'keyboard' && isFunctionKey(displayKey)) return `Key_${displayKey.toUpperCase()}`;
      if (deviceType === 'keyboard' && /^[a-z]$/i.test(displayKey)) return `Key_${displayKey.toUpperCase()}`;

      if (deviceType === 'mouse') {
        if (/maus\s*taste\s*\d+/i.test(displayKey) || /maus\s*\d+/i.test(displayKey)) {
          const num = displayKey.replace(/[^0-9]/g, '');
          if (num) return `Mouse_${num}`;
        }
        if (/rad\s*hoch|wheel\s*up/i.test(displayKey)) return 'Mouse_WheelUp';
        if (/rad\s*runter|rad\s*ab|wheel\s*down/i.test(displayKey)) return 'Mouse_WheelDown';
        if (/rad\s*links|wheel\s*left/i.test(displayKey)) return 'Mouse_WheelLeft';
        if (/rad\s*rechts|wheel\s*right/i.test(displayKey)) return 'Mouse_WheelRight';
        if (/linke|links/i.test(displayKey) && /maus/i.test(displayKey)) return 'Mouse_1';
        if (/rechte|rechts/i.test(displayKey) && /maus/i.test(displayKey)) return 'Mouse_2';
        if (/mittel/i.test(displayKey) && /maus|rad/i.test(displayKey)) return 'Mouse_3';
      }

      return displayKey;
    }

    /* ========= INPUT & DUPLICATES ========= */
    function handleInputChange(event) {
      const input = event.target;
      const bindingKey = input.getAttribute('data-binding');
      const deviceType = input.getAttribute('data-device');
      const displayValue = input.value.trim();
      const actualValue = reverseFormatKey(displayValue, deviceType);

      if (!currentConfig[bindingKey]) {
        const obj = {};
        availableDevices.forEach(d => (obj[d.key] = ''));
        currentConfig[bindingKey] = obj;
      }
      currentConfig[bindingKey][deviceType] = actualValue;
      updateStructureSlot(bindingKey, deviceType, actualValue);
    }

    function validateBinding(event) {
      const input = event.target;
      const bindingKey = input.getAttribute('data-binding');
      const deviceType = input.getAttribute('data-device');
      const displayValue = input.value.trim();
      const actualValue = reverseFormatKey(displayValue, deviceType);

      const oldValue = currentConfig[bindingKey]?.[deviceType];

      if (!actualValue) {
        if (oldValue) keyBindings.delete(`${deviceType}-${oldValue}`);
        currentConfig[bindingKey][deviceType] = '';
        updateStructureSlot(bindingKey, deviceType, '');
        input.classList.remove('duplicate-highlight');
        if (document.getElementById('templateOverlay').style.display === 'flex') buildTemplate(true);
        return;
      }

      const bindingId = `${deviceType}-${actualValue}`;

      if (keyBindings.has(bindingId)) {
        const existingBinding = keyBindings.get(bindingId);
        if (existingBinding !== bindingKey) {
          showDuplicateError(bindingKey, existingBinding, deviceType, displayValue, input);
          return;
        }
      }

      if (oldValue && oldValue !== actualValue) {
        const oldBindingId = `${deviceType}-${oldValue}`;
        keyBindings.delete(oldBindingId);
      }

      keyBindings.set(bindingId, bindingKey);
      currentConfig[bindingKey][deviceType] = actualValue;
      updateStructureSlot(bindingKey, deviceType, actualValue);
      input.classList.remove('duplicate-highlight');

      if (document.getElementById('templateOverlay').style.display === 'flex') buildTemplate(true);
    }

    function updateStructureSlot(bindingName, deviceType, actualKey){
      const st = structureMap[bindingName];
      if (!st) return;

      const deviceId = keyToDeviceId(deviceType);

      if (st.primary?.exists && st.primary.deviceId === deviceId){ st.primary.key = actualKey || ''; return; }
      if (st.secondary?.exists && st.secondary.deviceId === deviceId){ st.secondary.key = actualKey || ''; return; }
      const idx = st.bindings.findIndex(b => b.deviceId === deviceId);
      if (idx >= 0){ st.bindings[idx].key = actualKey || ''; return; }

      if (st.primary?.exists && (st.primary.deviceId === '{NoDevice}' || !st.primary.key)){
        st.primary.deviceId = deviceId; st.primary.key = actualKey || ''; return;
      }
      if (st.secondary?.exists && (st.secondary.deviceId === '{NoDevice}' || !st.secondary.key)){
        st.secondary.deviceId = deviceId; st.secondary.key = actualKey || ''; return;
      }
      st.bindings.push({ deviceId, key: actualKey || '' });
    }

    function showDuplicateError(newBinding, existingBinding, deviceType, key, inputElement) {
      duplicateContext = {
        newBinding, existingBinding, deviceType, key, inputElement, actualKey: reverseFormatKey(key, deviceType)
      };
      const msg = `Die Eingabe "${key}" ist bereits f√ºr "${formatBindingName(existingBinding)}" belegt (${deviceType}).`;
      document.getElementById('errorMessage').textContent = msg;
      document.getElementById('errorOverlay').style.display = 'flex';
      inputElement.classList.add('duplicate-highlight');
    }
    function resolveDuplicate(replace) {
      const ctx = duplicateContext;
      if (!ctx) { closeError(); return; }
      const { newBinding, existingBinding, deviceType, inputElement, actualKey } = ctx;

      if (replace) {
        if (currentConfig[existingBinding]) {
          const prev = currentConfig[existingBinding][deviceType];
          if (prev) keyBindings.delete(`${deviceType}-${prev}`);
          currentConfig[existingBinding][deviceType] = '';
          updateStructureSlot(existingBinding, deviceType, '');
          const otherInput = document.querySelector(`input[data-binding="${CSS.escape(existingBinding)}"][data-device="${CSS.escape(deviceType)}"]`);
          if (otherInput) { otherInput.value = ''; otherInput.classList.remove('duplicate-highlight'); }
        }
        currentConfig[newBinding][deviceType] = actualKey;
        keyBindings.set(`${deviceType}-${actualKey}`, newBinding);
        updateStructureSlot(newBinding, deviceType, actualKey);
        if (inputElement) { inputElement.value = formatKey(actualKey, deviceType.startsWith('gamepad') ? 'gamepad' : deviceType, deviceType); inputElement.classList.remove('duplicate-highlight'); }
      } else {
        const oldVal = currentConfig[newBinding]?.[deviceType] || '';
        if (inputElement) {
          inputElement.value = formatKey(oldVal, deviceType.startsWith('gamepad') ? 'gamepad' : deviceType, deviceType);
          inputElement.classList.remove('duplicate-highlight');
        }
      }
      document.getElementById('errorOverlay').style.display = 'none';
      duplicateContext = null;
      if (document.getElementById('templateOverlay').style.display === 'flex') buildTemplate(true);
    }
    function closeError() {
      document.getElementById('errorOverlay').style.display = 'none';
      duplicateContext = null;
    }

    /* ========= SEARCH ========= */
    function filterBindings() {
      const q = document.getElementById('searchBox').value.toLowerCase();
      document.querySelectorAll('.ac-item').forEach(item=>{
        let anyVisible = false;
        item.querySelectorAll('.binding-item').forEach(b=>{
          const label = b.querySelector('.binding-label').textContent.toLowerCase();
          const inputs = Array.from(b.querySelectorAll('input')).map(i=>i.value.toLowerCase());
          const visible = label.includes(q) || inputs.some(v=>v.includes(q));
          b.style.display = visible ? '' : 'none';
          if (visible) anyVisible = true;
        });
        item.style.display = anyVisible ? '' : 'none';
        if (q && anyVisible) item.classList.add('open');
        if (!q) item.classList.remove('open');
      });
    }

    /* ========= EXPORT ========= */
    function saveConfig() {
      try {
        const xmlContent = generateXML();
        const blob = new Blob([xmlContent], { type: 'application/xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = 'Test.binds';
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
        URL.revokeObjectURL(url);
        alert('Konfiguration erfolgreich als Test.binds gespeichert!');
      } catch (error) {
        alert('Fehler beim Speichern: ' + error.message);
      }
    }

    function generateXML() {
      const lines = [];
      lines.push('<?xml version="1.0" encoding="UTF-8" ?>');
      lines.push('<Root PresetName="Custom" MajorVersion="4" MinorVersion="2">');
      lines.push('  <KeyboardLayout>de-DE</KeyboardLayout>');
      lines.push('  <MouseXMode Value="Bindings_MouseYaw" />');
      lines.push('  <MouseXDecay Value="0" />');
      lines.push('  <MouseYMode Value="Bindings_MousePitch" />');
      lines.push('  <MouseYDecay Value="0" />');
      lines.push('  <MouseSensitivity Value="1.00000000" />');
      lines.push('  <MouseDecayRate Value="4.00000000" />');
      lines.push('  <MouseDeadzone Value="0.05000000" />');
      lines.push('  <MouseLinearity Value="1.00000000" />');
      lines.push('  <MouseGUI Value="1" />');

      for (const [bindingKey, st] of Object.entries(structureMap)) {
        lines.push(`  <${bindingKey}>`);

        if (st.primary && st.primary.exists) {
          const dev = st.primary.deviceId || '{NoDevice}';
          const key = st.primary.key || '';
          lines.push(`    <Primary Device="${dev}" Key="${key}" />`);
        } else {
          lines.push('    <Primary Device="{NoDevice}" Key="" />');
        }
        if (st.secondary && st.secondary.exists) {
          const dev = st.secondary.deviceId || '{NoDevice}';
          const key = st.secondary.key || '';
          lines.push(`    <Secondary Device="${dev}" Key="${key}" />`);
        } else {
          lines.push('    <Secondary Device="{NoDevice}" Key="" />');
        }

        if (Array.isArray(st.bindings)) {
          st.bindings.forEach(b => {
            const dev = b.deviceId || '{NoDevice}';
            const key = b.key || '';
            lines.push(`    <Binding Device="${dev}" Key="${key}" />`);
          });
        }
        if (Array.isArray(st.params)) {
          st.params.forEach(p => {
            lines.push(`    <${p.name} Value="${p.value ?? ''}" />`);
          });
        }
        lines.push(`  </${bindingKey}>`);
      }
      lines.push('</Root>');
      return lines.join('\n');
    }

    /* ========= RESET ========= */
    function resetConfig() {
      currentConfig = {};
      structureMap = {};
      keyBindings.clear();

      const search = document.getElementById('searchBox');
      if (search) search.value = '';

      availableDevices = [
        { key: 'keyboard', id: 'Keyboard', label: 'Tastatur', kind: 'keyboard', connected: true },
        { key: 'mouse',    id: 'Mouse',    label: 'Maus',      kind: 'mouse',    connected: true },
        { key: 'gamepad',  id: 'GamePad',  label: 'Gamecontroller (noch nicht aktiviert ‚Äì Knopf dr√ºcken)', kind: 'gamepad', connected: false, family: 'generic' }
      ];
      deviceIdMap = { 'Keyboard':'keyboard', 'Mouse':'mouse', 'GamePad':'gamepad' };

      initializeCategories();
      renderAccordion();
      refreshRuntimeDevices();
      renderDeviceBox();

      if (document.getElementById('templateOverlay').style.display === 'flex') buildTemplate(false);

      alert('Konfiguration zur√ºckgesetzt.');
    }

    /* ========= INIT ========= */
    document.getElementById('fileInput').addEventListener('change', loadConfig);
    document.addEventListener('DOMContentLoaded', () => {
      initializeCategories();
      availableDevices = [
        { key: 'keyboard', id: 'Keyboard', label: 'Tastatur', kind: 'keyboard', connected: true },
        { key: 'mouse',    id: 'Mouse',    label: 'Maus',      kind: 'mouse',    connected: true },
        { key: 'gamepad',  id: 'GamePad',  label: 'Gamecontroller (noch nicht aktiviert ‚Äì Knopf dr√ºcken)', kind: 'gamepad', connected: false, family: 'generic' }
      ];
      deviceIdMap = { 'Keyboard':'keyboard', 'Mouse':'mouse', 'GamePad':'gamepad' };

      renderAccordion();
      renderDeviceBox();

      const soundBtn = document.getElementById('toggle-sound-btn');
      if (soundBtn) soundBtn.addEventListener('click', toggleSound);

      
      // Wire toolbar + global print button
      const btnEdit = document.getElementById('btnLayoutEdit');
      const btnReset = document.getElementById('btnResetPositions');
      const btnPrintTpl = document.getElementById('btnPrintTemplate');
      if (btnEdit) btnEdit.addEventListener('click', toggleLayoutEdit);
      if (btnReset) btnReset.addEventListener('click', resetKeyOffsets);
      if (btnPrintTpl) btnPrintTpl.addEventListener('click', printTemplate);
      const btnPrint = document.getElementById('btn-print');
      if (btnPrint) btnPrint.addEventListener('click', printTemplate);
      loadKeyOffsets();
// headline toggle keep version
      const mainTitle = document.getElementById('mainTitle');
      const versionHtml = '<small class="ver" style="font-size:.55em;color:#aaa;">v08b</small>';
      const originalHtml = `<u>EliteDangerous - OfflineKeybinder</u> ${versionHtml}`;
      const altHtml = `<u>(w) 2025 by Beilrais</u> ${versionHtml}`;
      if (mainTitle) {
        mainTitle.innerHTML = originalHtml;
        mainTitle.dataset.state = 'orig';
        function toggleTitle() {
          if (mainTitle.dataset.state === 'orig') { mainTitle.dataset.state = 'alt'; mainTitle.innerHTML = altHtml; }
          else { mainTitle.dataset.state = 'orig'; mainTitle.innerHTML = originalHtml; }
        }
        mainTitle.addEventListener('click', toggleTitle);
        mainTitle.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); toggleTitle(); }
        });
      }

      // allow re-uploading same file
      const fileLabel = document.querySelector('label[for="fileInput"]');
      if (fileLabel) {
        fileLabel.addEventListener('mousedown', () => {
          const fi = document.getElementById('fileInput');
          if (fi) fi.value = '';
        });
      }

      // start device scan
      startAutoScan();
      window.addEventListener('gamepadconnected', ()=>refreshRuntimeDevices());
      window.addEventListener('gamepaddisconnected', ()=>refreshRuntimeDevices());
    });
  
    /* ========= DRAG / ANCHOR KEYS ========= */
    let layoutEditMode = false;
    let keyOffsets = {}; // { token: {dx, dy} }

    function loadKeyOffsets(){
      try {
        const raw = localStorage.getItem('kbKeyOffsets');
        keyOffsets = raw ? JSON.parse(raw) : {};
      } catch { keyOffsets = {}; }
    }
    function saveKeyOffsets(){
      try { localStorage.setItem('kbKeyOffsets', JSON.stringify(keyOffsets)); } catch {}
    }
    function resetKeyOffsets(){
      keyOffsets = {};
      saveKeyOffsets();
      // re-render to remove transforms
      try { buildTemplate(true); } catch(e){}
    }

    function applyOffsetToKeyEl(el, token){
      const off = keyOffsets[token];
      const dx = off?.dx || 0;
      const dy = off?.dy || 0;
      el.style.setProperty('--dx', dx + 'px');
      el.style.setProperty('--dy', dy + 'px');
    }

    function toggleLayoutEdit(){
      layoutEditMode = !layoutEditMode;
      const cont = document.getElementById('templateContainer');
      if (cont) cont.classList.toggle('editing', layoutEditMode);
      const b = document.getElementById('btnLayoutEdit');
      if (b) b.classList.toggle('active', layoutEditMode);
    }

    // Pointer-driven drag
    let dragCtx = null;
    function onKeyPointerDown(e){
      if (!layoutEditMode) return;
      const el = e.target.closest('.key');
      if (!el) return;
      e.preventDefault();
      const token = el.dataset.token;
      if (!token) return;
      const off = keyOffsets[token] || { dx: 0, dy: 0 };
      dragCtx = {
        el, token,
        startX: e.clientX, startY: e.clientY,
        baseDx: off.dx || 0, baseDy: off.dy || 0
      };
      el.setPointerCapture?.(e.pointerId || 0);
    }
    function onKeyPointerMove(e){
      if (!dragCtx) return;
      const dx = (e.clientX - dragCtx.startX) + dragCtx.baseDx;
      const dy = (e.clientY - dragCtx.startY) + dragCtx.baseDy;
      // optional snap (2px)
      const snap = 2;
      const sdx = Math.round(dx / snap) * snap;
      const sdy = Math.round(dy / snap) * snap;
      dragCtx.el.style.setProperty('--dx', sdx + 'px');
      dragCtx.el.style.setProperty('--dy', sdy + 'px');
    }
    function onKeyPointerUp(e){
      if (!dragCtx) return;
      const style = getComputedStyle(dragCtx.el);
      const dx = parseFloat(style.getPropertyValue('--dx')) || 0;
      const dy = parseFloat(style.getPropertyValue('--dy')) || 0;
      keyOffsets[dragCtx.token] = { dx, dy };
      saveKeyOffsets();
      dragCtx.el.releasePointerCapture?.(e.pointerId || 0);
      dragCtx = null;
    }

    // Hook handlers on the keyboard template host
    (function setupDragDelegates(){
      const host = document.getElementById('keyboardTemplate');
      // No host yet at load time; we re-wire when template shows
      function wire(){
        const h = document.getElementById('keyboardTemplate');
        if (!h || h._dragWired) return;
        h.addEventListener('pointerdown', onKeyPointerDown);
        h.addEventListener('pointermove', onKeyPointerMove);
        window.addEventListener('pointerup', onKeyPointerUp);
        h._dragWired = true;
      }
      document.addEventListener('DOMContentLoaded', wire);
      // Also wire each time we open the template
      const oldShowTemplate = showTemplate;
      window.showTemplate = function(){
        oldShowTemplate();
        setTimeout(wire, 0);
      };
    })();

    /* ========= APPLY OFFSETS WHEN BUILDING ========= */
    // Patch generateKeyboardLayout to set dataset.token and apply offsets
    (function patchGenerateKeyboardLayout(){
      const original = generateKeyboardLayout;
      window.generateKeyboardLayout = function(host, allowedSet){
        loadKeyOffsets();
        // Wrap addKey by temporary hooking via closure trick: we cannot access inner addKey.
        // Instead, run original to build keys, then iterate to apply offsets and tokens are already embedded by our modified template below.
        original(host, allowedSet);
        // After original build, apply saved offsets to each key that has data-token
        host.querySelectorAll('.key[data-token]').forEach(el=>{
          applyOffsetToKeyEl(el, el.dataset.token);
        });
      };
    })();

    /* ========= PRINT ========= */
    function printTemplate(){
      const overlay = document.getElementById('templateOverlay');
      const wasHidden = overlay && overlay.style.display !== 'flex';
      if (wasHidden) { showTemplate(); }
      // Give the overlay a tick to render
      setTimeout(()=>{
        // Slightly reduce zoom for paper if it's too large
        try {
          const cont = document.getElementById('templateContainer');
          const z = parseFloat(getComputedStyle(cont).getPropertyValue('--kb-zoom')) || 1;
          if (z > 1.4) applyTemplateZoom(1.2);
        } catch(e){}
        window.print();
      }, 80);
    }

  </script>
</body>
</html>
